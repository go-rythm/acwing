## [3279. 字符画](https://www.acwing.com/problem/content/3282/)

### 题目

君君是个喜欢旅行的女孩子，世界那么大，她哪里都想去看看。

这个暑假，她踏遍了大江南北，感慨于祖国幅员的辽阔。

开学了，君君打算整理一下最近拍的照片，却发现自己电脑上 Linux 的图形界面似乎罢工了。

面对着终端里不断闪动的光标，她灵机一动......

本题中，你需要将图片转换为终端中可以显示的字符画。

你将得到一张 *24* 位图片，这意味着其中的像素表示为 RGB 三原色的形式，而每种颜色的取值范围为 *0* 到 *255*(一个字节)，因此每个像素占用的空间为 *24* 比特。

你需要这张图片分割为指定数量的块。

对于每一块，你需要计算所有像素的三个颜色分量的 **平均值**，并输出对应颜色的字符形成字符画。

为了在终端中输出彩色的字符，你需要使用特殊的转义序列。

在目前通行的终端规范中，与颜色相关的转义序列包括:

- `ESC [ 38; 2; R; G; B m` 更改终端的 **前景色（字符的颜色）** 为 *(R,G,B)*
- `Esc [ 48; 2; R; G; B m` 更改终端的 **背景色（未被字符遮盖处的颜色）** 为 *(R,G,B)*
- `ESc [ 0 m` 重置终端的颜色状态为默认值（前景色为白色 *(255,255,255)*，背景色为黑色 *(0,0,0)*）

你只需要在输出中加入这些转义序列，就能够控制终端中显示的字符颜色。

在书写转义序列时，有以下注意事项:

- 所有空格都是为了方便辨认而添加的， **不需要出现** 在实际的转义序列输出中
- `ESC` **不是字面上的三个字符**，而是 ASCII 序号为 *27*(八进制表示为 *033*）的一个字符，代表转义序列的开始。在C/C++/Java/Python中，你都可以使用 `033` 或 `x1b` 来在字符串中使用这个字符。
- 每个颜色分量的值需要在 *0* 到 *255* 的范围内
- 对终端状态的更改在当前转义序列结束（即最后的 *m* 字符）后立刻生效，直到下一个序列再次改变状态为止

为了更方便理解，我们给出一个例子:

```
033[38;2;255;0;0mHello033[0m 033[38;2;0;0;255m033[48;2;255;255;255mWorld033[0mn
```

当这个字符串被输出到终端中，你将会看到类似下面的效果:

 ![QQ截图20210223140711.png](https://cdn.acwing.com/media/article/image/2021/02/23/19_6505491275-QQ截图20210223140711.png)

特别需要注意的是，在程序完成输出后，应该主动恢复终端的颜色状态，否则可能让之后运行的程序表现异常。

### 输入格式

输入的第一行为两个整数 *m,n*，分别表示图片的宽和高。

第二行为两个整数 *p,q*，分别表示每一小块的宽和高。保证 *p* 整除 *m*，并且 *q* 整除 *n*，也就是说图片总是能被分割成整数块。

接下来共有 *m × n* 行，每一行是图片中的一个像素，按照从左到右、从上到下的顺序列出，即先从左到右输入第一行，再输入第二行，依此类推。每个像素的颜色以 HTML 颜色代码的形式表示，格式为 `#abcdef`，表示该像素的 *R、G、B* 三个分量分别是( `0xab，0xcd，0xef`)（注意为 *16* 进制)。此外，为了使得表达简洁， `#aabbcc` 可以被缩写为 `#abc`， `#aaaaaa` 可以被缩写为 `#a`，你需要处理这些情况。

### 输出格式

输出包含两部分，每一个输出中应该有恰好 *(mn)/(pq)* 个空格（ ``)以及 *n/q* 个换行符( `n`)，和若干个转义序列。

空格用于绘制色块（呈现出的即为其 **背景色**)，转义序列用于改变颜色。

每一个色块都由 *p × q* 个像素组成，其三个颜色分量值分别是对应区域中所有像素该分量值的平均值（除法向零取整即可)。

由于正确的答案显然不止一种，为了方便判定，我们有以下的约定:

- 初始时终端的前景色和背景色都为默认值（前景白色，背景黑色）。
- 减少控制序列的冗余，这包含以下的情况:
    - 如果下一个字符的颜色刚好与默认值完全相同，你应当直接使用重置转义序列，而非手动更改颜色
    - 如果某个字符的前景色/背景色与其前一个字符相同，或者对颜色的更改并不影响最终显示效果，则不应该出现更改这个属性的控制序列
- 在输出每一行字符后，如果终端颜色不是默认值，你应该重置终端的颜色状态

为了便于观察和评测，你需要将输出中的所有字符转换为 ASCII 编码转义后的格式再进行输出。

即，如果某个字符的 *16* 进制编码是 `0xAB`，则你应该在输出文件中写入 `xAB`，注意大小写。所有的字符都需要被转义（包括空格、换行等空白字符）；所有字符的转义序列顺序输出，不需要任何形式的分隔符号；在输出所有的转义序列后，不需要写入换行符。也就是说，最终的输出文件只有一行，并且其中所有内容都是原本输出字符的 ASCII 转义序列。

### 数据范围

 ![QQ截图20210223141652.png](https://cdn.acwing.com/media/article/image/2021/02/23/19_bea0882675-QQ截图20210223141652.png)

### 输入样例1：

```
1 1
1 1
#010203
```

### 输出样例1：

```
x1Bx5Bx34x38x3Bx32x3Bx31x3Bx32x3Bx33x6Dx20x1Bx5Bx30x6Dx0A
```

### 样例1解释

输入文件图片大小为 *1 × 1*，要求的色块大小为 *1 × 1*，因此原样输出即可。在输出后需要重置背景色。

### 输入样例2：

```
2 2
1 2
#111111
#0
#000000
#111
```

### 输入样例2：

```
x1Bx5Bx34x38x3Bx32x3Bx38x3Bx38x3Bx38x6Dx20x20x1Bx5Bx30x6Dx0A
```

### 样例2解释

输入文件图片大小为 *2 × 2*，要求的色块大小为 *1 × 2*，因此将被切为两个色块。

第一个色块的颜色是左侧两个像素的平均值，三个颜色分量为 *(8,8,8)*;第二个色块同理，计算得到的颜色分量相同。因此最终只需要更改一次终端的背景色，并输出两个空格用于显示即可。
