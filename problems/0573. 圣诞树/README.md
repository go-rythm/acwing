## [573. 圣诞树](https://www.acwing.com/problem/content/575/)

### 题目

给定你一个 *N* 行和 *M* 列的矩形网格。

该网格的每个单元格都涂有两种颜色中的一种：绿色和白色。

你的任务是找到此网格中最大的圣诞树中的绿色单元格数。

要定义圣诞树，首先我们定义一个好的三角形为：

顶点坐标为 *(R,C)* ，高度为 *h*（*h> 0*）并且完全由绿色单元格组成并指向上方的等腰三角形即为一个好三角形。

也就是说，顶点坐标为 *(R,C)*，高度为 *h* 的好三角形需满足：单元格 *(R，C)* 是绿色，并且对于 *0 ≤ i ≤ h-1*，满足第 *R + i* 行的第 *C - i* 列到第 *C + i* 列的单元格是绿色。

例如：

```
..#..
.####
#####
```

是一个高度为 *3* 的好三角形，其中 `＃` 表示绿色单元格， `.` 表示白色单元格。

请注意，有一个绿色单元格虽然与好三角形相连但是并不属于好三角形的一部分。

```
..#..
.###.
####.
```

不是高度为 *3* 的好三角形，因为第 *3* 行中的第 *5* 个单元格是白色的。

但是，图中存在高度为 *2* 的好三角形。

```
...#.
.###.
#####.
```

不是一个高度为 *3* 的好三角形。但是，图中存在高度为 *2* 的好三角形。

*K*-圣诞树定义如下：

它包含垂直排列的 *K* 个好三角形。

第 *i + 1* 个三角形的顶部单元格必须与第 *i* 个三角形的底部某个单元格相连。

这意味着，如果第 *r* 行的第 *c_1* 列到第 *c_2* 列的单元格构成了第 *i* 个三角形的底部，则第 *i + 1* 个三角形的顶部单元格必须位于第 *r + 1* 行的第 *c_1* 列到第 *c_2* 列之间。

例如，如果 *K = 2*：

```
...#...
..###..
.#####.
#######
..#....
.###...
#####..
```

是一个有效的 *2*-圣诞树。

请注意，*2* 个好三角形的高度可以不同。

```
..#..
.###.
.#...
```

也是一个有效的 *2*-圣诞树。

请注意，一个好三角形的高度可以为 *1* 并且只由一个绿色单元格构成。

```
...#...
..###..
.#####.
.......
..#....
.###...
#####..
```

图中的两个高度为 *3* 的好三角形不会形成有效的 *2*-圣诞树，因为第 *2* 个好三角形的顶部必须位于第四行。

```
...#.
..###
.#...
###..
```

图中的两个高度为 *2* 的好三角形不会形成有效的 *2*-圣诞树，因为第 *2* 个好三角形的顶部必须位于第 *3* 列到第 *5* 列之间。

你需要找到包含绿色单元格最多的 *K*-圣诞树。

### 输入格式

第一行包含整数 *T*，表示共有 *T* 组测试数据。

每组数据的第一行包含三个整数 *N，M，K*，其中 *N* 是网格的行数，*M* 是网格的列数，*K* 是所需圣诞树中的好三角形的数量。

接下来 *N* 行，每行包含一个长度为 *M* 的字符串，字符串由 `#` 和 `.` 构成，其中 `#` 表示绿色单元格， `.` 表示白色单元格。

### 输出格式

每组数据输出一个结果，每个结果占一行。

结果表示为 `Case #x: y`，其中 *x* 为组别编号（从 *1* 开始），*y* 为 *K*-圣诞树可包含的最大绿色单元格数。

如果 *K*-圣诞树不存在，则输出 *0*。

### 数据范围

*1 ≤ T,N,M,K ≤ 100*

### 输入样例：

```
4
3 5 1
..#..
.###.
#####
3 5 1
.....
.....
.....
4 5 1
#####
#####
#####
#####
4 5 2
#####
#####
#####
#####
```

### 输出样例：

```
Case #1: 9
Case #2: 0
Case #3: 9
Case #4: 10
```
