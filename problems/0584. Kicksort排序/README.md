## [584. Kicksort排序](https://www.acwing.com/problem/content/586/)

### 题目

在 Kickstart，我们非常喜欢众所周知的 Quicksort 算法。

在 Quicksort 算法中，需要从列表中选择一个关键数，让其他数与关键数作比较，并根据该数与关键数的比较结果将它放入两个新列表中的一个，然后在每个新列表中进行递归排序。

但是，该算法可能会出现一种特殊情况，即选择了一个特殊的关键数，导致其他所有数都被分到同一个新列表中（都比关键数大或都比关键数小），这违背了分而治之策略的目的。

我们将这种关键数称为最坏情况的关键数。

为了避免这个问题，我们创建了自己的变体 Kicksort。

有人告诉我们，使用位于序列中间的数作为关键数很不错，所以我们的算法如下工作：

```
Kicksort(A): // A is a 0-indexed array with E elements
    If E ≤ 1, return A.
    Otherwise:
      Create empty new lists B and C.
      Choose A[floor((E-1)/2)] as the pivot P.
      For i = 0 to E-1, except for i = floor((E-1)/2):
        If A[i] ≤ P, append it to B.
        Otherwise, append it to C.
    Return the list Kicksort(B) + P + Kicksort(C).
```

为了验证这一方法，我们生成了很多由数字 *1* 到 *N* 随机排列形成的数字列表，并用 Kicksort 排序法进行排序。

不幸的是，看起来 Kicksort 仍然有与 Quicksort 相同的问题：每个关键数都可能成为最坏情况的关键数！

例如，考虑列表 `1 4 3 2`，Kicksort 将选择 *4* 作为关键数，这将使得 `1 3 2` 全部被分配到同一个新列表中。

然后，当在列表 `1 3 2` 上调用 Kicksort 时，它将选择 *3* 作为关键数，这将使得 `1 2` 全部被分配到同一个新列表中。

最后，它将从列表 `1 2` 中选择 *1*，而另一个值 *2* 当然被分配到了一个新列表中。

在每一个步骤中，算法都会选择最坏情况的关键数。 （请注意，当在具有 *0* 或 *1* 个元素的列表上调用 Kicksort 时，它根本不会选择关键数。）

请帮助我们进一步调查，给定由数字 *1* 到 *N* 构成的列表，确定 Kicksort 是否只选择最坏情况的关键数。

### 输入格式

第一行包含整数 *T*，表示共有 *T* 组测试数据。

每组数据占两行，第一行包含整数 *N*，表示列表长度。

第二行包含 *N* 个整数，它们是 *1* 到 *N* 这 *N* 个数字的一种排列。

### 输出格式

每组数据输出一个结果，每个结果占一行。

结果表示为 `Case #x: y`，其中 *x* 是组别编号（从 *1* 开始），如果 Kicksort 在排序此列表时仅选择最坏情况的关键数，则 *y* 为 `YES`，否则为 `NO`。

### 数据范围

*1 ≤ T ≤ 100*,

*2 ≤ N ≤ 10000*

### 输入样例：

```
4
4
1 4 3 2
4
2 1 3 4
2
2 1
3
1 2 3
```

### 输出样例：

```
Case #1: YES
Case #2: NO
Case #3: YES
Case #4: NO
```

### 样例解释

样例＃1是问题陈述中描述的样例。

在样例＃2中，我们的第一个关键数将是 *1*，这是最坏情况的关键数，因为它导致所有其他值 `2 3 4` 最终被分配到同一个新列表中。 但是，列表 `2 3 4` 上调用 Kicksort 时将选择 *3* 作为关键数。 这不是最坏情况的关键数，因为它将 *2* 放在一个新列表中，而将 *4* 放在了另一个新列表中。

在样例＃3中，Kicksort 将从选择最坏情况的关键数 *2* 开始，并且没有其他关键数供其选择。

在样例＃4中，Kicksort 将从选择 *2* 开始，这不是最坏情况的关键数。
