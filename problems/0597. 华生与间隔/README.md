## [597. 华生与间隔](https://www.acwing.com/problem/content/599/)

### 题目

夏洛克和华生在编程课程中已经掌握了 C ++ 语言的复杂性，因此他们转而研究算法问题。

在今天的课堂上，导师介绍了合并一维间隔的问题。

给出 *N* 个间隔，并且第 *i* 个间隔由构成间隔的两个端点 *[L_i,R_i]* 定义，其中 *L_i ≤ R_i*。

导师将一组间隔的覆盖区域定义为存在于至少一个间隔中的整数的数量。 （也就是对于所有的 *j*，使 *L_j ≤ p ≤ R_j* 得到满足的整数 *p* 的数量。）

现在，华生想考考夏洛克。

他要求夏洛克删除给定间隔中的一个，以使剩余间隔的覆盖区域最小化。

你能帮助夏洛克找到在删除 *N* 个间隔中的一个之后，覆盖区域的最小可能值吗？

### 输入格式

第一行包含整数 *T*，表示共有 *T* 组测试数据。

每组数据数据占一行，包含八个整数 *N, L_1, R_1, A, B, C_1, C_2, M*，其中 *N* 是间隔的数量，其余七个是用于生成其他间隔的参数，如下：

首先定义 *x_1 = L_1* 和 *y_1 = R_1*，然后，使用下列等式生成 *i = 2* 到 *N* 的 *x_i,y_i*：

*x_i = ( A × x_{i-1} + B × y_{i-1} + C_1 ) bmod M*

*y_i = ( A × y_{i-1} + B × x_{i-1} + C_2 ) bmod M*

对于所有 *i=2* 到 *N* 我们定义 *L_i = min(x_i, y_i)* 以及 *R_i = max(x_i, y_i)*。

### 输出格式

每组数据输出一个结果，每个结果占一行。

结果表示为 `Case #x: y`，其中 *x* 是组别编号（从 *1* 开始），*y* 是删除一个间隔后剩余的所有间隔的覆盖区域的最小可能值。

### 数据范围

*1 ≤ T ≤ 50*,

*0 ≤ L_1 ≤ R_1 ≤ 10^9*,

*0 ≤ A,B,C_1,C_2 ≤ 10^9*,

*1 ≤ M ≤ 10^9*,

*1 ≤ N ≤ 5*10^5*

### 输入样例：

```
3
1 1 1 1 1 1 1 1
3 2 5 1 2 3 4 10
4 3 4 3 3 8 10 10
```

### 输出样例：

```
Case #1: 0
Case #2: 4
Case #3: 9
```

### 样例解释

在样例#1中，使用给定生成区间方法，生成的区间集合为：*{[1,1]}*。 删除唯一的间隔，覆盖区域为 *0*。

在样例#2中，使用给定生成区间方法，生成的区间集合为：*{[2,5]，[3,5]，[4,7]}*。 去除第一，第二或第三间隔后剩余间隔的覆盖区域分别为 *5,6* 和 *4*。

在样例#3中，使用给定生成区间方法，生成的区间集合为：*{[3,4]，[1,9]，[0,8]，[2,4]}*。 去除第一，第二，第三或第四间隔后剩余间隔的覆盖区域分别为 *10,9,9* 和 *10*。
