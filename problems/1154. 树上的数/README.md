## [1154. 树上的数](https://www.acwing.com/problem/content/1156/)

### 题目

给定一个大小为 *n* 的树，它共有 *n* 个结点与 *n − 1* 条边，结点从 *1* ∼ *n* 编号。

初始时每个结点上都有一个 *1* ∼ *n* 的数字，且每个 *1* ∼ *n* 的数字都只在 **恰好** 一个结点上出现。

接下来你需要进行 **恰好** *n − 1* 次删边操作，每次操作你需要选一条 **未被删去** 的边，此时这条边所连接的两个结点上的数字将会 **交换**，然后这条边将被删去。

*n − 1* 次操作过后，所有的边都将被删去。

此时，按数字从小到大的顺序，将数字 *1* ∼ *n* 所在的结点编号依次排列，就得到一个结点编号的排列 *P_i*。

现在请你求出，在最优操作方案下能得到的 **字典序最小** 的 *P_i*。

 ![QQ截图20191116200647.png](https://cdn.acwing.com/media/article/image/2019/11/16/19_959d718a08-QQ截图20191116200647.png)

如上图，蓝圈中的数字 *1* ∼ *5* 一开始分别在结点 *2 、1 、3 、5 、4*。按照 *(1)(4)(3)(2)* 的顺序删去所有边，树变为下图。

按数字顺序得到的结点编号排列为 *13425* ，该排列是所有可能的结果中字典序最小的。

 ![QQ截图20191116200929.png](https://cdn.acwing.com/media/article/image/2019/11/16/19_f4c9c1e008-QQ截图20191116200929.png)

### 输入格式

第一行一个正整数 *T*，表示数据组数。

对于每组测试数据：

第一行一个整数 *n*，表示树的大小。

第二行 *n* 个整数，第 *i*（*1 ≤ i ≤ n*）个整数表示数字 *i* 初始时所在的结点编号。

接下来 *n − 1* 行每行两个整数 *x, y*，表示一条连接 *x* 号结点与 *y* 号结点的边。

### 输出格式

对于每组测试数据，输出一行共 *n* 个用空格隔开的整数，表示最优操作方案下所能得到的字典序最小的 *P_i*。

### 数据范围

 ![QQ截图20191116201307.png](https://cdn.acwing.com/media/article/image/2019/11/16/19_79b263d008-QQ截图20191116201307.png)

对于所有测试点：*1 ≤ T ≤ 10*，保证给出的是一个树。

### 输入样例：

```
4
5
2 1 3 5 4
1 3
1 4
2 4
4 5
5
3 4 2 1 5
1 2
2 3
3 4
4 5
5
1 2 5 3 4
1 2
1 3
1 4
1 5
10
1 2 3 4 5 7 8 9 10 6
1 2
1 3
1 4
1 5
5 6
6 7
7 8
8 9
9 10
```

### 输出样例：

```
1 3 4 2 5
1 3 5 2 4
2 3 1 4 5
2 3 4 5 6 1 7 8 9 10
```
