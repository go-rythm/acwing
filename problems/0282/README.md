## [282\. 石子合并](https://www.acwing.com/problem/content/284/)

### 题目

设有 $N$ 堆石子排成一排，其编号为 $1，2，3，…，N$。

每堆石子有一定的质量，可以用一个整数来描述，现在要将这 $N$ 堆石子合并成为一堆。

每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。

例如有 $4$ 堆石子分别为 `1  3  5  2`， 我们可以先合并 $1、2$ 堆，代价为 $4$，得到 `4 5 2`， 又合并 $1，2$ 堆，代价为 $9$，得到 `9 2` ，再合并得到 $11$，总代价为 $4+9+11=24$；

如果第二步是先合并 $2，3$ 堆，则代价为 $7$，得到 `4 7`，最后一次合并代价为 $11$，总代价为 $4+7+11=22$。

问题是：找出一种合理的方法，使总的代价最小，输出最小代价。

### 输入格式

第一行一个数 $N$ 表示石子的堆数 $N$。

第二行 $N$ 个数，表示每堆石子的质量(均不超过 $1000$)。

### 输出格式

输出一个整数，表示最小代价。

### 数据范围

$1 \\le N \\le 300$

### 输入样例：

```
4
1 3 5 2
```

### 输出样例：

```
22
```

### 题解

前置题目：0899

前置知识：前缀和

本题知识：动态规划-区间DP

#### 题目分析

区间DP：只将相邻的合并，具有阶段性

属性：合并的最小代价

![石子合并](https://raw.githubusercontent.com/luxcgo/imgs4md/master/img/%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6.png)

#### 实现细节

* 枚举所有种情况：
    * 第一重循环，所有区间长度
    * 第二重循环，所有左端点
* 当区间长度为 1 时，只有一堆，所以合并代价为 0。
* 合并代价的计算：分为左右两堆分别的最小代价，加上合并这两堆的代价（使用前缀和提前计算）

#### 代码鉴赏

```go
for len := 2; len <= n; len++ {
    for l := 1; l+len-1 <= n; l++ {
        r := l + len - 1
        f[l][r] = inf
        w := s[r] - s[l-1]
        for k := 0; k < r-l; k++ {
            f[l][r] = oj.Min(f[l][r], f[l][l+k]+f[l+k+1][r]+w)
        }
    }
}
```

