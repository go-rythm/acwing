## [479. 加分二叉树](https://www.acwing.com/problem/content/481/)

### 题目

设一个 *n* 个节点的二叉树 tree 的中序遍历为（*1,2,3,…,n*），其中数字 *1,2,3,…,n* 为节点编号。

每个节点都有一个分数（均为正整数），记第 *i* 个节点的分数为 *d_i*，tree 及它的每个子树都有一个加分，任一棵子树 subtree（也包含 tree 本身）的加分计算方法如下：

subtree的左子树的加分 *×* subtree的右子树的加分 *＋* subtree的根的分数

若某个子树为空，规定其加分为 *1*。

叶子的加分就是叶节点本身的分数，不考虑它的空子树。

试求一棵符合中序遍历为（*1,2,3,…,n*）且加分最高的二叉树 tree。

要求输出：

（1）tree的最高加分

（2）tree的前序遍历

### 输入格式

第 *1* 行：一个整数 *n*，为节点个数。

第 *2* 行：*n* 个用空格隔开的整数，为每个节点的分数（*0<*分数*<100*）。

### 输出格式

第 *1* 行：一个整数，为最高加分（结果不会超过 `int` 范围）。

第 *2* 行：*n* 个用空格隔开的整数，为该树的前序遍历。如果存在多种方案，则输出字典序最小的方案。

### 数据范围

*n < 30*

### 输入样例：

```
5
5 7 1 2 10
```

### 输出样例：

```
145
3 1 2 4 5
```
