## [541. 夏洛克和比特串](https://www.acwing.com/problem/content/543/)

### 题目

夏洛克和华生正在玩一个涉及比特串（即只包含数字 *0* 和 *1* 的字符串）的游戏。

华生提出让夏洛克生成一个由 *N* 个字符 *S_1，S_2，…，S_N* 构成的比特串 *S*。

该比特串必须遵循 *K* 个约束限制，每个约束包含三个整数参数 *A_i,B_i,C_i*。

第 *i* 条约束规定比特串 *S* 的子串 *S_{A_i}，S_{A_i + 1}，…，S_{B_i}* 中的 *1* 的数量必须等于 *C_i*。

华生保证满足所有约束的比特串一定存在。

但是，由于可能存在多个满足约束的比特串，因此华生希望夏洛克找出按字典序排序第 *P* 个满足约束的比特串，*P* 从 *1* 开始计数。

### 输入格式

第一行包含整数 *T*，表示共有 *T* 组测试数据。

每组测试数据第一行包含三个整数 *N，K* 和 *P*。

接下来 *K* 行，第 *i* 行包含三个整数 *A_i,B_i,C_i*，表示第 *i* 个约束的参数。

### 输出格式

每组数据输出一个结果，每个结果占一行。

结果表示为 `Case #x: y`，其中 *x* 为组别编号（从 *1* 开始），*y* 为所有满足约束的比特串中，按字典序排序的第 *P* 个字符串。

### 数据范围

*1 ≤ T,N,K ≤ 100*,

*1 ≤ P ≤ min(10^{18},所有满足约束的比特串数)*,

*1 ≤ A_i ≤ B_i ≤ N*,

*0 ≤ C_i ≤ N*,

*B_i - A_i ≤ 15*,

*对于所有1le i < j ≤ k，满足(A_i,B_i) ≠ (A_j,B_j)*

### 输入样例：

```
2
3 1 2
2 2 1
4 3 1
1 2 1
2 3 1
3 4 1
```

### 输出样例：

```
Case #1: 011
Case #2: 0101
```

### 样例解释

在样例*＃1*中，满足所有约束的字符串按字典序排序为 *[010,011,110,111]*。

在样例*＃2*中，满足所有约束的字符串按字典序排序为 *[0101,1010]*。
