## [3269. CIDR合并](https://www.acwing.com/problem/content/3272/)

### 题目

在如今的互联网中，路由器扮演了一种很重要的角色，它可以高效而快速地处理 IP 数据包，根据其目的地址和路由规则，投向不同的下一个路由器。

自 Internet 建成以来，全球的 IPv4 路由条目稳步增长，根据 CIDR-Report 组织的统计，目前已经接近 *80* 万条；IPv6 的路由条目也超过了 *6* 万条。

如此巨量的路由条目给骨干网上的路由器带来了很大的存储与处理压力。

为了节约路由器资源，很多路由器都会设法缩减路由表的大小。

在本题中，你需要实现一个通过合并前缀条目来缩减前缀列表的算法。

为了简便起见，我们暂时不考虑 IPv6 地址。

**IP 地址及其表示**

**IP 地址** 是一个 *32* 位无符号整数。

为了方便人类阅读，IP 地址可以被表示为 **点分十进制** 的形式: *a_3.a_2.a_1.a_0*，其中诸 *a_i in [0,256)*，是用十进制表示的 **不含前导零** 的整数。

*a_3.a_2.a_1.a_0* 所表示的 IP 地址是 *sumlimits_{k=0}^3a_k × 256^k*。

例如 *101.6.6.6* 表示的 IP 地址是十进制整数 *1694893574* 或十六进制整数 *0x65060606*。

下面示意性地列举一些合法和不合法的点分十进制表示的 IP 地址：

- *0.0.0.0* 是合法的点分十进制表示；
- *1.255.255.255* 是合法的点分十进制表示；
- *101.6* 不是合法的点分十进制表示，因为它位数不足；
- *101.006.006.001* 不是合法的点分十进制表示，因为它的后三段整数都含有前导零；
- *101.6.123.456* 不是合法的点分十进制表示，因为它的最后一段数字超过了 *255*。

由上述定义易知，任何一个 IP 地址都有其点分十进制表示，并且任何合法的点分十进制的表示都唯一对应一个 IP 地址。

因此为了叙述方便，我们不再区分 IP 地址和它的点分十进制表示，你应当理解二者的等价性。

**IP 前缀与前缀列表**

**IP 前缀** 是由一个 IP 地址和一个数字组成的有序二元组 *< ip, len >*，其中 *len in [0,32]* 称为 **前缀长度**，且 *ip* 的低 *(32 - len)* 二进制位为 *0*。

IP 前缀一般写作 *a_3.a_2.a_1.a_0/len* 的形式，其中 *“a_3.a_2.a_1 .a_0”* 是 *ip* 的点分十进制的表示，*“len”* 是十进制表示的数字， **不含前导零**，二者用斜线分开。

下面示意性地列举一些合法和不合法的 IP 前缀：

- *0.0.0.0/0* 是合法的 IP 前缀；
- *0.0.0.0/1* 是合法的 IP 前缀；
- *1.2.0.0/16* 是合法的 IP 前缀；
- *1.2.0.0/8* 不是合法的 IP 前缀，因为 IP 地址 *1.2.0.0* 实际是十六进制数 *0x01020000*，其低 *24* 位不都是 *0*；
- *1.2.0.0/33* 不是合法的 IP 前缀，因为它的前缀长度超过了 *32*。

**前缀列表** 是一个或多个 IP 前缀的 **无序可重复集合**。

**IP 地址和 IP 前缀的匹配关系**

一个 IP 地址 *ip* 和一个 IP 前缀 *< pref,len >* **匹配**，是指 *ip* 的高 *len* 二进制位与 *pref* 的高 *len* 二进制位相同。

一个 IP 地址和一个前缀列表 **匹配**，是指这个 IP 地址至少和这个前缀列表中的一个 IP 前缀匹配。

我们定义一个 IP 前缀或前缀列表的 **匹配集** 为与这个 IP 前缀（列表）匹配的全体 IP 地址的集合。例如：

- *101.6.6.6* 与 *101.6.6.0/24、101.6.6.0/23、101.6.0.0/16、101.0.0.0/8* 都匹配，但是与 *101.6.0.0/24* 不匹配；
- *101.6.6.0/24* 的匹配集包含了从 *101.6.6.0* 开始，到 *101.6.6.255* 为止的所有 IP 地址；
- *101.6.6.128/25* 的匹配集包含了从 *101.6.6.128* 开始，到 *101.6.6.255* 为止的所有 IP 地址；
- 前缀列表 *101.6.6.0/24，101.6.6.128/25* 的匹配集包含了从 *101.6.6.0* 开始，到 *101.6.6.255* 为止的所有 IP 地址；
- *101.6.6.6/32* 的匹配集中只有一个元素：*101.6.6.6*；
- *0.0.0.0/0* 的匹配集是全体 IP 地址。

**等价前缀列表**

两个前缀列表 **等价**，是指这两个前缀列表的匹配集相等。例如:

- 前缀列表 *101.6.6.0/24，101.6.6.128/25* 与前缀列表 *101.6.6.0/24* 等价；
- 前缀列表 *101.6.6.0/24，101.6.7.0/24* 与前缀列表 *101.6.6.0/23* 等价。

本题中，你将会得到一个前缀列表。

你的任务是，找到与之等价的包含 IP 前缀数目最少的前缀列表。

你的程序将会具有很高的实用价值，因此我们希望你的程序能够处理下面这几种简写形式的 IP 前缀：

- 标准型：形如 *a_3.a_2.a_1.a_0/len*。例如: *101.6.6.0/24*;
- 省略后缀型：在标准型的基础上，可以只写出 IP 地址的高位部分位段，没有写出的位段认为是 *0*；但 IP 地址至少要写一段。例如:
    - *101.6.6/23* 意为 *101.6.6.0/23*；
    - *101/8* 意为 *101.0.0.0/8*；
    - *1/32* 意为 *1.0.0.0/32*；
- 省略长度型：当前缀长度是 *8、16、24* 或 *32* 时，可以省略斜线和前缀长度不写，IP 地址只相应地写出前 *1、2、3* 或 *4* 段。例如:
    - *101.6.6.0* 意为 *101.6.6.0/32*;
    - *101.6* 意为 *101.6.0.0/16*；
    - *1* 意为 *1.0.0.0/8*。

### 输入格式

输入的第一行包含一个正整数 *n*，表示输入的前缀列表有 *n* 条 IP 前缀。

接下来的 *n* 行，每行一个 **合法的** IP 前缀。IP 前缀可能是标准型、省略后缀型、省略长度型中的任意一种。

### 输出格式

输出与输入前缀列表等价的包含 IP 前缀数目最少的前缀列表。

每个 IP 前缀占一行，用标准型输出。

输出的 IP 前缀按 IP 地址从小到大、前缀长度从小到大的顺序输出。

### 数据范围

*1 ≤ n ≤ 10^5*,

有些测试点具有特殊的性质：

- 测试点 *1,2,3,4* 保证输出的 IP 前缀个数与输入的个数相同。这说明你不需要处理合并的情况，只需要完成排序的操作。
- 测试点 *1,2,5,6* 保证输入中只有标准型的 IP 前缀，即输入中没有省略的情况。

测试点的输入数据规模:

- 前 *8* 个测试点保证 *n ≤ 100*。
- 第 *9* 个测试点保证 *n ≤ 10^4*。
- 第 *10* 个测试点保证 *n ≤ 10^5*。

### 输入样例1：

```
2
1
2
```

### 输出样例1：

```
1.0.0.0/8
2.0.0.0/8
```

### 输入样例2：

```
2
10/9
10.128/9
```

### 输出样例2：

```
10.0.0.0/8
```

### 输入样例3：

```
2
0/1
128/1
```

### 输出样例3：

```
0.0.0.0/0
```

### 提示

你可以用这样的办法计算包含 IP 前缀数目最少的等价前缀列表:

第一步:排序

将所有 IP 前缀进行排序，以其 IP 地址为第一关键字，以前缀长度为第二关键字从小到大排序，形成一个列表。

第二步:从小到大合并

从头到尾扫描该列表，依次考虑其相邻的两个元索 *a,b*：如果 *b* 的匹配集是 *a* 的匹配集的子集，则将 *b* 从列表中移除。如果 *b* 后仍有元素 *c*，则此时 *a* 与 *c* 变为相邻的元素，你应当继续考虑这对新的相邻元素，直到 *a* 的下一个元素不能被移除。然后继续依次处理列表中接下来的相邻元素。可以证明，在此趟扫描结束之后，列表中不会存在任何两个元素 *a,b* 使得 *b* 的匹配集是 *a* 的匹配集的子集。

第三步:同级合并

从头到尾扫描该列表，依次考虑其相邻的两个元素 *a,b*：如果 *a* 与 *b* 的前缀长度相同，则设 *a’* 为一个新的 IP 前缀，其 IP 地址与 *a* 相同，而前缀长度比 *a* 少 *1*。如果 *a’* 合法且 *a* 的匹配集与 *b* 的匹配集的并集等于 *a’* 的匹配集，则将 *a* 与 *b* 从列表中移除，并将 *a’* 插入到列表中原来 *a,b* 的位置。与上一步不同的是，如果 *a’* 之前存在元素，则接下来应当从 *a* 的前一个元素开始考虑；否则继续从 *a’* 开始考虑。
