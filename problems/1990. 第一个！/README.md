## [1990. 第一个！](https://www.acwing.com/problem/content/1992/)

### 题目

贝茜又开始玩字符串了。

她发现通过改变字母表中字母的顺序，可以使某些字符串在字典序中排在所有其他字符串之前。

例如，贝茜发现对于字符串 `omm, moo, mom, ommnom`，在标准字母表顺序下，字典序最小的字符串为 `mom`，而在 `abcdefghijklonmpqrstuvwxyz` 的顺序下，字典序最小的字符串为 `omm`。

然而，贝茜想不出任何办法（通过改变字母表中字母的顺序）使得 `moo` 或 `ommnom` 成为字典序最小的字符串。

计算输入的哪些字符串可以通过改变字母表中字母顺序的方法（当然也可以不改），成为给定字符串中字典序最小的字符串。

要判断字符串 *X* 是否按照字典序排在字符串 *Y* 之前，需找到第一个索引 *j* 满足 *X[j] ≠ Y[j]*。

如果 *X[j]* 在字母表中比 *Y[j]* 靠前，则字符串 *X* 按照字典序排在字符串 *Y* 之前。

当不存在这样的索引 *j* 时，如果 *X* 短于 *Y*，则则字符串 *X* 按照字典序排在字符串 *Y* 之前。

### 输入格式

第一行包含整数 *N*，表示字符串个数。

接下来 *N* 行，每行包含一个非空字符串。

所有字符串由小写字母构成，且互不相同。

### 输出格式

第一行输出一个整数 *K*，表示能够成为给定字符串中字典序最小的字符串的字符串个数。

接下来 *K* 行，按照输入顺序，每行输出一个满足要求的字符串。

### 数据范围

*1 ≤ N ≤ 30000*,

所有字符串的总长度不超过 *300000*。

### 输入样例：

```
4
omm
moo
mom
ommnom
```

### 输出样例：

```
2
omm
mom
```
