## [630. 数组排序](https://www.acwing.com/problem/content/632/)

### 题目

我们正在构造一种新的排序算法，对由 *1* 到 *N* 之间的所有整数构成的队列 *A* 进行排序。

*A* 的初始顺序随意。

除了队列初始顺序以外，算法仍需要用到两个整数参数 *P*（不超过 *3*）和 *K*。

以下是算法的工作原理：

1. 将 *A* 分成 *K* 个不相交的非空子阵列 *A_1,A_2,…,A_K*，使得它们按照 *A_1A_2 … A_K* 的顺序连接起来可以得到 *A*。
2. 单独对每个子阵列进行排序。
3. 选择最多 *P* 个子阵列，这 *P* 个子阵列之间可作任意次数的任意两两位置调换。

例如，考虑 `A = [1 5 4 3 2]` 和 *P = 2*，一个可行的划分子阵列的方式为将 *A* 分成 *K = 4* 个不相交子阵列：

```
A1 = [1]
A2 = [5]
A3 = [4]
A4 = [3 2]
```

排序每个子阵列后：

```
A1 = [1]
A2 = [5]
A3 = [4]
A4 = [2 3]
```

交换 *A4* 和 *A2* 后：

```
A1 = [1]
A2 = [2 3]
A3 = [4]
A4 = [5]
```

将四个子阵列按顺序连接起来，即可获得排列好顺序的队列 *A*。

现在给定初始队列顺序以及 *P*，请你算出 *K* 的最大值是多少。

### 输入格式

第一行包含整数 *T*，表示共有 *T* 组测试数据。

每组数据第一行包含两个整数 *N* 和 *P*。

第二行包含 *N* 个整数 *X_1,X_2,…,X_N*，表示队列 A。

### 输出格式

每组数据输出一个结果，每个结果占一行。

结果表示为 `Case #x: y`，其中 *x* 是组别编号（从 *1* 开始），*y* 是 *K* 的最大可能值。

### 数据范围

*1 ≤ T ≤ 100*,

*1 ≤ N ≤ 1200*,

*1 ≤ X_i ≤ N*,

*X_i ≠ X_j*,

*2 ≤ P ≤ 3*

### 输入样例：

```
5
5 2
1 5 4 3 2
5 2
4 5 1 2 3
6 2
6 3 5 2 4 1
5 3
4 5 1 2 3
6 3
1 2 6 4 5 3
```

### 输出样例：

```
Case #1: 4
Case #2: 2
Case #3: 3
Case #4: 3
Case #5: 6
```

### 样例解释

样例#1：

见题目描述。

样例＃2：

`[4 5] [1 2 3]`

交换 *2* 个子阵列： `[1 2 3] [4 5]`

样例＃3：

`[6] [3 5 2 4] [1]`

排序 `[3 5 2 4]`，然后交换 `[6]` 和 `[1]`，得到： `[1] [2 3 4 5] [6]`

样例＃4：

`[4 5] [1] [2 3]`

交换 `[4 5]` 和 `[1]`，然后交换 `[2 3]` 和 `[4 5]`： `[1] [2 3] [4 5]`

样例＃5：

`[1] [2] [6] [4] [5] [3]`

交换 `[6]` 和 `[3]`： `[1] [2] [3] [4] [5] [6]`
