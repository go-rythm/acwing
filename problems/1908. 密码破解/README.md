## [1908. 密码破解](https://www.acwing.com/problem/content/1910/)

### 题目

奶牛骑着农夫约翰的拖拉机不停的惹麻烦，所以他把拖拉机的钥匙藏在了办公室一个新的保险箱里。

奶牛们发誓一定要破开这个保险箱。

保险箱由相当复杂的密码系统保护。

密码输入系统被安排为一个 *N* 个节点的有根树。

每个节点处都需要填入 *0 ~ 9* 之间的一位密码。

所有节点的编号从 *0* 到 *N-1*。

奶牛们所拥有的唯一信息是，某些长度为 *5* 的密码序列不会在沿着树 **向上** 的特定路径中出现。

例如，假设树如下所示（根节点为 *A*）：

```
A <- B <- C <- D <- E
               ^
               |
               F
```

奶牛们知道密码序列 *01234* 不会出现在以 *F* 作为开头的路径中，密码序列 *91234* 也不会出现在以 *E* 作为开头的路径中。

以上信息可以排除掉 *19* 种可能的密码：所有以下形式的密码

```
4 <- 3 <- 2 <- 1 <- *
               ^
               |
               0
```

或者

```
4 <- 3 <- 2 <- 1 <- 9
               ^
               |
               *
```

以上形式密码共 *19* 种，是因为考虑到：

```
4 <- 3 <- 2 <- 1 <- 9
               ^
               |
               0
```

出现了两次。

给定 *M* 个长度为 *5* 的密码序列，以及它们在树中的起始节点。

请帮助奶牛计算，共可以排除掉多少种可能的密码。

结果对 *1234567* 取模后输出。

### 输入格式

第 *1* 行包含两个整数 *N* 和 *M*。

第 *2..N* 行，第 *i+1* 行包含一个整数 *p_i*，表示节点 *i* 在树中的父节点编号。

第 *N+1 .. N+M* 行，第 *N+i* 行描述了第 *i* 个不会出现的密码序列。该行将包含 *v_i* 和 *s_i*，其中 *v_i* 是密码序列的起始节点，*s_i* 是 *5* 位密码序列。该密码序列一定不会出现在以 *v_i* 开头的在树中 **向上前行** 的路径中。

保证根节点至少在 *v_i* 上方 *4* 单位距离以上。

### 输出格式

输出可以排除掉的密码数量对 *1234567* 取模后的结果。

### 数据范围

*1 ≤ N ≤ 20000*,

*1 ≤ M ≤ 50000*,

*0 ≤ p_i < i*,

### 输入样例：

```
6 2
0
1
2
3
3
4 01234
5 91234
```

### 输出样例：

```
19
```
