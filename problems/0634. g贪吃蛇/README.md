## [634. g贪吃蛇](https://www.acwing.com/problem/content/636/)

### 题目

Alex 是贪吃蛇游戏的忠实粉丝。

 ![untitled.png](https://cdn.acwing.com/media/article/image/2019/04/08/19_213e9adc5a-untitled.png)

注意：上图与我们将在下面介绍的贪吃蛇游戏规则不完全一致。

它只是为了让你大致了解游戏的外观。

Alex 刚刚学会了如何编程并希望开发自己的贪吃蛇版本，并遵循以下规则：

- 游戏地图有 *R* 行和 *C* 列。地图的左上方单元的坐标为 *(1,1)*，右下方单元的坐标为 *(R,C)*。
- 在游戏开始时，在每个坐标为 *(r,c)* 的单元格中，如果 *r + c* 为奇数，则单元格中有一块食物，否则单元格内将没有食物。
- 蛇的身体始终是地图上一个或多个单元格的有序连接序列。序列的第一个单元格称为蛇的“头”。第二个单元格（如果有的话）与第一个单元格共享边缘，依此类推。序列中的最后一个单元格称为蛇的“尾巴”。
- 蛇的头部始终面向四个方向之一：左，上，右或下。
- 在比赛开始时，蛇位于单元格 *(1,1)* 并且长度为 *1*（即蛇只由头部组成），头部朝向右侧。
- 在每个整数时间（*1* 秒，*2* 秒等），蛇的头部将移动到其头部朝向的相邻单元格中。该地图是循环的，即，试图走出地图边缘将导致头部出现在地图的相对边缘上。例如，如果蛇头位于 *(1,C)* 并且其头部朝向右侧，则头部将接下来移动到 *(1,1)*。如果蛇头位于 *(1,C)* 并且其头部朝上，则头部将接下来移动到 *(R,C)*。
- 当蛇的头部进入没有食物的单元格时，蛇就不会生长。蛇的第二个单元格（如果有的话）移动到蛇的头部，蛇的第三个单元格（如果有的话）移动到第二个单元格所在的地方，依此类推。
- 当蛇的头部进入带有食物的单元格时，它会吞食食物（意味着单元格内不再有食物），并使其身体生长。在食物所在的单元格中产生一个新头。蛇头的单元格成为蛇的第二个单元格，蛇的第二个单元格（如果有的话）成为蛇的第三个单元格，依此类推。
- 如果移动完成后，蛇的头与其身体的某个单元格位于同一个位置，则蛇死亡并且游戏立即结束。 （请注意，如果蛇的头部向尾部所在的单元移动，则游戏将不会结束，因为尾部将在移动完成之前移开。）
- 在游戏中，玩家可以让蛇执行一些转弯动作。每个动作 *A_i* 将发生在第 *T_i* 和 *T_i + 1* 秒之间。有两种可能的动作：*“L”* 和 *“R”*。 *“L”* 动作会将头部向左转 *90* 度，因此，如果蛇面朝下前进时进行 *“L”* 动作，它将面向右侧。 *“R”* 动作会将头部向右转 *90* 度，因此，如果蛇面朝下前进时进行 *“R”* 动作，它将面向左侧。
- 游戏有一个时间限制：它将在第 *10^9* 秒的移动完成后结束（如果游戏甚至已经持续了那么久！）

为了测试游戏，Alex 写了一系列转向动作。

你的任务是模拟这一系列动作，并在游戏结束时告诉 Alex 蛇的最终长度。

请记住，如果蛇的头部和身体的其他单元格在移动完成后位于同一个地方，游戏就会结束。

如果时间耗尽，游戏也会结束。

在前一种情况下，为了确定蛇的长度，你应该将蛇的头部和与其发生重叠的身体单元格计为两个单独的单元格。

### 输入格式

第一行包含整数 *T*，表示共有 *T* 组测试数据。

每组数据包含三个整数 *S,R,C*，其中 *S* 表示转向动作的数量，*R* 和 *C* 表示地图的行数和列数。

接下来 *S* 行，每行包含用空格隔开的一个整数 *X_i* 和一个字符 *A_i*(*L* 或 *R* 中的一个)，表示在第 *X_i* 秒和 *X_i+1* 秒之间，蛇将进行给定转向动作。

数据保证按时间顺序给出所有动作指令，并且不会在同一时间给蛇多个动作指令。

但是，需要注意游戏可能会在蛇执行完所有操作之前结束。

### 输出格式

每组数据输出一个结果，每个结果占一行。

结果表示为 `Case #x: y`，其中 *x* 是组别编号（从 *1* 开始），*y* 是游戏结束时蛇的长度。

### 数据范围

*1 ≤ T ≤ 10*,

*1 ≤ R,C ≤ 10^5*,

*1 ≤ S ≤ 10^5*,

*1 ≤ X_i ≤ 10^6*

### 输入样例：

```
2
3 3 3
1 R
2 L
3 R
5 3 3
2 R
4 R
6 R
7 R
8 R
```

### 输出样例：

```
Case #1: 3
Case #2: 5
```
