## [586. 抓住它们](https://www.acwing.com/problem/content/588/)

### 题目

在 Codejamon Go 发布之后，你和许多朋友一样，走上了城市的街头，去尽可能多地抓住那些毛茸茸的 Codejamon。

游戏的目的是通过前往各个 Codejamon 的位置捕捉出现在城市周围的 Codejamon。

你想知道你需要多长时间才能抓住它们！

你的城市由 *N* 个位置组成，编号从 *1* 到 *N*。

你在开始时处在位置 *1*。

有 *M* 条双向道路（编号从 *1* 到 *M*），第 *i* 条道路连接一对不同的位置 *(U_i,V_i)*，并且从一端走到另一端需要花费 *D_i* 分钟。

保证从位置 *1* 可以通过在一条或多条道路到达任何其他位置。

在时间 *0*，一只 Codejamon 将均匀随机的出现在除当前位置（在时间 *0* 处为位置 *1*）之外的任意位置中。

均匀随机意味着它出现在除当前位置之外的每个位置的概率都正好是 *1/(N-1)*。

Codejamon 出现的瞬间，你可以立即开始向它迈进。

当你到达包含 Codejamon 的位置时，你立即捕获它，然后新的 Codejamon 将立即均匀随机的出现在你当前位置以外的某个位置中，依此类推。

请注意，在任何给定时间只有一个 Codejamon 存在，你必须在下一个 Codejamon 出现之前捕获现有的 Codejamon。

考虑到你所在城市的布局，计算捕获 *P* 只 Codejamon 的预期时间，假设你始终在任意两个位置之间采取最快的路线。

### 输入格式

第一行包含整数 *T*，表示共有 *T* 组测试数据。

每组数据第一行包含三个整数 *N、M、P*，分别表示位置数量，道路数量以及 Codejamon 数量。

接下来 *M* 行，每行包含三个整数 *U_i,V_i,D_i*，表示在位置 *U_i* 和 *V_i* 之间存在一条道路，通过道路需要花费的时间为 *D_i*。

### 输出格式

每组数据输出一个结果，每个结果占一行。

结果表示为 `Case #x: y`，其中 *x* 是组别编号（从 *1* 开始），*y* 是捕获 *P* 只 Codejamon 的预期时间（以分钟为单位）。

*y* 在正确答案的 *10^{-4}* 的绝对或相对误差范围内，则视为正确。

### 数据范围

*1 ≤ T ≤ 100*,

*N-1 ≤ M ≤ N*(N-1)/2*,

*1 ≤ D_i ≤ 10*,

*1 ≤ U_i < V_i ≤ N*,

*2 ≤ N ≤ 100*,

*1 ≤ P ≤ 10^9*,

任意两个位置之间最多存在一条道路将二者直接连接起来。

### 输入样例：

```
4
5 4 1
1 2 1
2 3 2
1 4 2
4 5 1
2 1 200
1 2 5
5 4 2
1 2 1
2 3 2
1 4 2
4 5 1
3 3 1
1 2 3
1 3 1
2 3 1
```

### 输出样例：

```
Case #1: 2.250000
Case #2: 1000.000000
Case #3: 5.437500
Case #4: 1.500000
```

### 样例解释

在样例＃1中，我们只能找到一个 Codejamon。它将以相同的概率出现在位置 *2,3,4,5* 处，它们分别距离我们的起始位置 *1* 的距离为 *1,3,2,3*，因此预期的时间是 *(1 + 3 + 2 + 3)/ 4 = 2.25* 分钟。

在样例＃2中，只有两个位置通过一条道路连接。每当 Codejamon 出现时，它将位于另一个位置，我们直接去寻找它即可。所以我们共走 *200* 次，每次 *5* 分钟，总共 *1000* 分钟。

样例＃3使用与样例＃1相同的城市构图。对于两个 Codejamon 将出现的位置有 *16* 个可能的有序对，通过数学计算得出预期为 *87/16 = 5.4375* 分钟。

在样例＃4中，我们需要捕获的一个 Codejamon，它将出现在位置 *2* 或位置 *3*。需注意的是如果出现在位置 *2*，那么从 *1* 到 *2* 的最快路程为 *1 to 3 to 2* 共计 *2* 分钟路程。所以预期的时间是 *(2 + 1)/ 2 = 1.5* 分钟。
