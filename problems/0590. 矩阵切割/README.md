## [590. 矩阵切割](https://www.acwing.com/problem/content/592/)

### 题目

Shekhu教授有一个 *N* 行 *M* 列的矩阵，其中行从上到下按 *0* 到 *N-1* 编号，列从左到右按 *0* 到 *M-1* 编号。

矩阵中的每个单元格包含一个正整数。

他想通过水平和垂直切割将这个矩阵切割成 *N × M* 个子矩阵（每个子矩阵大小为 *1 × 1*）。

注意，只能在两行或两列之间的边界上进行切割。

Shekhu 教授找来了他最好的学生 Akki 来完成这项工作并提出一个有趣的建议。

每次 Akki 在某个子矩阵中进行切割时，在他进行切割之前，他都会获得等于该子矩阵包含的最小数值的硬币数量。

请注意，每次切割时，子矩阵的总数都会增加。

此外，任意两个不同子矩阵的切割是独立的，同样，Akki 对不同子矩阵的每次切割都是独立的。

现在，Akki 有多种方式可以进行切割。

你可以通过最大化他可以获得的硬币总数来帮助他吗？

### 输入格式

第一行包含整数 *T*，表示共有 *T* 组测试数据。

每组数据第一行包含整数 *N* 和 *M*。

接下来 *N* 行每行包含 *M* 个正整数（均不超过 *10^5*），用以描绘整个矩阵。

### 输出格式

每组数据输出一个结果，每个结果占一行。

结果表示为 `Case #x: y`，其中 *x* 是组别编号（从 *1* 开始），*y* 是 Akki 可以获得的最大硬币数量。

### 数据范围

*1 ≤ T ≤ 100*,

*1 ≤ N,M ≤ 40*

### 输入样例：

```
3
2 2
1 2
3 4
2 3
1 2 1
2 3 2
1 2
1 2
```

### 输出样例：

```
Case #1: 5
Case #2: 7
Case #3: 1
```

### 样例解释

在样例＃1中，Akki可以通过两种方式进行裁剪。

1、假设 Akki 首先水平切割矩阵。他得到等同矩阵中的最小值：*1* 的硬币。然后他必须在两个子矩阵（*[1,2]* 和 *[3,4]*）中进行垂直切割，分别得到 *1* 个和 *3* 个硬币，总计 *5* 个硬币。

2、假设 Akki 首先垂直切割矩阵。他得到等同矩阵中的最小值：*1* 的硬币。然后他必须在两个子矩阵（*[1,3]* 和 *[2,4]*）中进行水平切割，分别得到 *1* 个和 *2* 个硬币，总计 *4* 个硬币。

显然，第一个策略更好，答案是 *5*。

在样例＃2中，Akki 最多可以获得 *7* 个硬币。具体操作方法为，首先水平切割，得到两个子矩阵 *[1,2,1]* 和 *[2,3,2]*。然后两个子矩阵分别从左到右依次垂直切割即可。

在样例＃3中，只需要进行一次切割，所以答案只能是 *1*。
