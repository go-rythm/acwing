## [3261. 二次求和](https://www.acwing.com/problem/content/3264/)

### 题目

给一棵 *n* 个节点的树，用 *1* 到 *n* 的整数表示。

每个节点上有一个整数权值 *a_i*。

再给出两个整数 *L,R*。

现在有 *m* 个操作，每个操作这样描述：

给定树上两个节点 *u,v* 和一个整数 *d*，表示将树上 *u* 到 *v* 唯一的简单路径上每个点的权值 *a_i* 都加上 *d*。

之后求树上所有节点个数大于等于 *L* 小于等于 *R* 的简单路径的节点权值和之和。

注意这里有两次求和：

对于一条节点个数大于等于 *L* 小于等于 *R* 的简单路径，求出它所有节点的权值之和；然后对所有这样的路径，对它们的权值和再进行求和。

因为答案很大，只用输出对 *Q=1,000,000,007* 取余的结果即可。

### 输入格式

包含多组数据。

数据的第一行包含一个正整数 *T*，表示数据组数。保证 *T=10*。

每组数据的第一行包含 *4* 个非负整数 *n,m,L,R*，分别表示节点个数、操作个数和询问相关的两个参数。保证 *1≤L≤R≤n*。

第二行包含 *n* 个整数，表示 *a_i*。保证 *0≤a_i<Q*。

第三行包含 *n-1* 个整数，描述树的形态，其中第 *i* 个数 *f_i* 表示节点 *i+1* 与节点 *f_i* 之间有一条边，保证 *1≤f_i≤i<n*。

能够证明，这样能够保证给出的是一棵树。

接下来 *m* 行，每行包含三个整数 *u,v,d*，描述一个操作即将树上 *u* 到 *v* 唯一的简单路径上每个点的权值 *a_i* 都加上 *d*，之后询问满足条件的两次求和的结果。保证 *1≤u,v≤n，0≤d<Q*。

保证上述同一行所有的数之间，均用一个空格隔开。

### 输出格式

每组数据输出 *m* 行，每行一个整数，表示两次求和的结果对 *Q=10^9+7* 求余的结果。

### 数据范围

共有 *10* 个测试点，各测试点特点如下：

- 测试点 *1*：*n=10，m=10*。
- 测试点 *2*：*n=50，m=50*。
- 测试点 *3*：*n=300，m=300*。
- 测试点 *4*：*n=2000，m=2000*。
- 测试点 *5*：*n=2000，m=100000*。
- 测试点 *6*：*n=100000，m=100000*。保证 *f_i=i*。
- 测试点 *7*：*n=100000，m=100000*。保证 *f_i=⌊(i+1)/2⌋*，其中 *⌊⋅⌋* 表示向下取整，即给定的树是完全二叉树。
- 测试点 *8*：*n=100000，m=100000*。保证对于同一组数据，相同的 *f_i* 至多出现 *2* 次，即给定的树是二叉树。
- 测试点 *9*：*n=100000，m=100000*。
- 测试点 *10*：*n=100000，m=100000*。

上述约束对同一测试点中的每组数据都有效。

### 输入样例：

```
1
10 10 3 6
36 11 76 24 71 89 24 63 75 40
1 1 2 2 3 3 4 4 5
2 5 18
5 7 95
7 10 82
8 2 99
8 1 85
7 7 60
1 5 85
4 3 38
9 4 17
1 1 99
```

### 输出样例：

```
7591
17186
26124
32163
39473
39953
46073
49835
50328
52803
```
