## [1825. 瓷器店里的公牛](https://www.acwing.com/problem/content/1827/)

### 题目

农夫约翰认为自己的家里需要更多的装饰。

在参观当地的瓷器店时，他发现了一个精致的玻璃牛挂件，并认为这十分适合放在壁炉架上，所以他决定买下这个挂件。

牛挂件的形状可以用一个 *N×N* 的字符矩阵来描述，如下所示，其中 `#` 是挂件的部分，而 `.` 不是挂件的部分（就是空气）。

```
...............
...............
...............
#..#...........
####...........
############...
.##.#########..
....#######.##.
....##...##....
....##...##....
...............
...............
...............
...............
...............
```

不幸的是，约翰还没来得及掏钱购买，就有一只公牛闯进了商店，不仅撞坏了约翰的挂件，还撞坏了货架上的许多其他玻璃制品！

约翰的小挂件被撞成了两块碎片，与其他商品碎片散落在地上，已知地上目前共有 *K* 块碎片。

就像最初的小挂件一样，每块碎片的形状都由一个 *N×N* 的字符矩阵来描述。

请帮助约翰找出哪两块碎片可以拼接在一起将牛挂件修复。

幸运的是，挂件的两个碎片掉在地上时，并没有发生旋转或翻转。

因此要重新拼接它们，约翰只需要沿着水平或垂直方向移动它们，然后将它们黏在一起就行了。

如果约翰找对了两个碎片，那么它们就应该恰好拼接出与原来完全一样的图案，原始图案中的每一个 `#` 都只在其中一个碎片中出现一次。（即，这两个碎片在移动和拼接时，不应该有任何重叠部分，要恰好准确的拼出原始图案）

约翰可以沿水平或垂直方向随意移动碎片，但是，不得将碎片中的任何 `#` 字符移出 *N × N* 的原始矩阵之外。

每个碎片中的 `#` 不一定是完全连通的，但是，如果一个碎片内包含多个不相交的 `#` 连通集，那么当移动碎片时，所有连通集的移动量必须相同。

### 输入格式

第一行包含 *N* 和 *K*。

接下来 *N* 行，描述原始牛挂件的字符矩阵。

再接下来 *KN* 行，给出 *K* 个字符矩阵，用来描述 *K* 个碎片。

### 输出格式

输出一行两个整数，每个整数范围在 *1…K*，表示用来拼接牛挂件的两个碎片的编号。

保证存在唯一解。

输出的两个碎片的编号按升序排序。

### 数据范围

*3 ≤ N ≤ 8*,

*3 ≤ K ≤ 10*

### 输入样例：

```
4 3
####
#..#
#.##
....
.#..
.#..
##..
....
####
##..
#..#
####
....
.###
.#..
.#..
```

### 输出样例：

```
1 3
```
