## [2136. 潘多拉的宝盒](https://www.acwing.com/problem/content/2138/)

### 题目

传说中，有个神奇的潘多拉宝盒。

如果谁能打开，便可以拥有幸福、财富、爱情。

可是直到真的打开，才发现与之相随的还有灾难、不幸。

其实，在潘多拉制造这个宝盒的时候，设置了一些咒语来封锁住灾难与不幸。

然而，直到科技高度发达的今天，人们才有希望弄懂这些咒语。

所以说，上千年来，人们只得忍受着各种各样的疾病和死亡的痛苦。

然而，人类的命运从此改变了。

经过数十年的研究，NOI组织在最近终于弄清楚了潘多拉咒语的原理。

咒语是由一个叫做咒语机的机器产生的。

用现在的名词来解释，咒语机其实就是一个二进制产生器，它产生的一个二进制字符串（这个字符串叫做咒语源）经加密后就形成了咒语。

咒语机由 *n* 个元件组成，不妨设这 *n* 个元件的标号为 *0* 到 *n-1*。

咒语机通过这些元件生成包含二进制字符串的信号的原理如下：

1. 最开始，有一个空串信号停留在元件 *0* 上。
2. 信号可以在元件之间传递，每个时刻，都有且仅有一个信号停留在某个元件上。
3. 当信号停留在元件 *i* 上时，元件 *i* 可将信号传递给另外两个元件 *p_{i,0}* 或 *p_{i,1}* 之一。具体传递规则为：(1) 传递前必须在原信号后面增加一位 *0* 或 *1*。(2) 如果增加位是 *0*，则必须将信号传递给 *p_{i,0}*。(3) 如果增加位是 *1*，则必须将信号传递给 *p_{i,1}*。
4. 一些元件可以将停留在其上面的信号直接输出，而输出的信号就成为了咒语源，这样的元件叫做咒语源输出元。

不难发现，有些咒语源是可能由一个咒语机产生的，而有些咒语源则不行。

例如，下图的咒语机（由 *0,1* 两个元件构成，且元件 *0* 为咒语源输出元）能产生 *1,11,111,1111,…* 等咒语源，但是不能产生 *0,10,101* 等咒语源。

 ![QQ截图20200716141552.png](https://cdn.acwing.com/media/article/image/2020/07/16/19_d0540ca4c7-QQ截图20200716141552.png)

在潘多拉宝盒中，共有 *K* 个咒语机，不妨将这些咒语机从 *0* 到 *K－1* 标号。

可能出现这种情况，一个咒语机 *i* 能够产生的咒语源，咒语机 *j* 都能产生。

这时，我们称咒语机 *j* 是咒语机 *i* 的升级。

我们现在需要找到这个宝盒中升级次数最多的一个咒语机。

即：找到一个最长的升级序列 *a_1,a_2,…,a_t*。

该升级序列满足：序列中任意两个咒语机的标号都不同，且都是 *0* 到 *k-1*（包含 *0* 和 *k-1*）之间的整数，且咒语机 *a_2* 是咒语机 *a_1* 的升级，咒语机 *a_3* 是咒语机 *a_2* 的升级，…，咒语机 *a_t* 是咒语机 *a_{t-1}* 的升级。

你想远离灾难与不幸吗？

你想从今以后沐浴幸福的阳光吗？

请打开你的潘多拉之盒吧。

不过在打开它之前，你先得计算一下宝盒上最长的升级序列的长度。

### 输入格式

第一行是一个正整数 *S*，表示宝盒上咒语机的个数。

以下分为 *S* 块，每一块描述一个咒语机，按照咒语机 *0*,咒语机 *1* …咒语机 *S－1* 的顺序描述。

每一块的格式如下。

一块的第一行有两个正整数 *n,m*。分别表示该咒语机中元件的个数、咒语源输出元的个数。

接下来一行有 *m* 个数，表示 *m* 个咒语源输出元的标号（都在 *0* 到 *n-1* 之间）。

接下来有 *n* 行，每一行两个数。第 *i* 行 *(0≤i≤n-1)* 的两个数表示 *p_{i,0}* 和 *p_{i,1}*（当然，都在 *0* 到 *n-1* 之间）。

### 输出格式

输出一个整数 *t*，表示最长升级序列的长度。

### 数据范围

*1 ≤ S ≤ 50*,

*1 ≤ m ≤ n ≤ 50*

### 输入样例：

```
4
1  1
0
0  0
2  1
0
1  1
0  0
3  1
0
1  1
2  2
0  0
4  1
0
1  1
2  2
3  3
0  0
```

### 输出样例：

```
3
```
