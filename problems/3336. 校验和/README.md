## [3336. 校验和](https://www.acwing.com/problem/content/3339/)

### 题目

Grace 和 Edsger 正在构造一个 *N×N* 布尔矩阵 *A*。

第 *i* 行第 *j* 列的元素用 *A_{i,j}* 来表示。

他们决定记下每行和每列的校验和（定义为某行或某列的所有元素按位异或（*XOR*）的结果）。

第 *i* 行的校验和表示为 *R_i*，第 *j* 列的校验和表示为 *C_j*。

例如，如果 *N=2*，*A=begin{bmatrix} 1 & 1 newline 0 & 1 end{bmatrix}*，则 *R = [1,0]*，*C = [0,1]*。

矩阵构建完成后，Edsger 就会将其储存在自己的计算机中。

然而，在某种病毒的影响下，他储存的矩阵 *A* 中的一些元素被替换为了 *-1*。

幸运的是，他还记得校验和的值。

现在，他想还原矩阵，只靠校验和信息推导可能无法将矩阵完全还原，所以他还找了 Grace 来帮忙。

Grace 可以通过恢复磁盘的方式找回被替换的数据，但是这是个耗费时间的工作，恢复 *A_{i,j}* 的值需要花费 *B_{i,j}* 小时的时间。

因为 Grace 很忙，所以麻烦他找回数据所花费的总时间越短越好。

现在，给定最终矩阵 *A*，耗时矩阵 *B*，每一行的校验和（*R*），每一列的校验和（*C*）。

请你计算，要想完全恢复矩阵 *A*，Grace 最少需要花费多少小时的时间。

### 输入格式

第一行包含整数 *T*，共有 *T* 组测试数据。

每组数据第一行包含整数 *N*。

接下来 *N* 行，每行包含 *N* 个整数，用来描述矩阵 *A*，其中第 *i* 行第 *j* 列的数表示 *A_{i,j}*。

再接下来 *N* 行，每行包含 *N* 个整数，用来描述矩阵 *B*，其中第 *i* 行第 *j* 列的数表示 *B_{i,j}*。

再接下来一行，包含 *N* 个整数，用来描述所有行的校验和，其中第 *i* 个整数表示第 *i* 行的校验和 *R_i*。

再接下来一行，包含 *N* 个整数，用来描述所有列的校验和，其中第 *j* 个整数表示第 *j* 行的校验和 *C_j*。

### 输出格式

每组数据输出一个结果，每个结果占一行。

结果表示为 `Case #x: y`，其中 *x* 为组别编号（从 *1* 开始），*y* 为 Grace 最少需要花费的时间。

### 数据范围

*1 ≤ T ≤ 100*,

*-1 ≤ A_{i,j} ≤ 1*,

对于所有 *i,j*，若 *A_{i,j}=-1* 成立，则 *1 ≤ B_{i,j} ≤ 1000*，否则，*B_{i,j}= 0*。

*0 ≤ R_i,C_j ≤ 1*,

保证至少存在一种用 *0* 或 *1* 替换 *A* 中 *-1* 的方法，使得 *R* 和 *C* 都得到满足。

*1 ≤ N ≤ 500*

### 输入样例：

```
3
3
1 -1 0
0 1 0
1 1 1
0 1 0
0 0 0
0 0 0
1 1 1
0 0 1
2
-1 -1
-1 -1
1 10
100 1000
1 0
0 1
3
-1 -1 -1
-1 -1 -1
0 0 0
1 1 3
5 1 4
0 0 0
0 0 0
0 0 0
```

### 输出样例：

```
Case #1: 0
Case #2: 1
Case #3: 2
```

### 样例解释

对于测试数据 *1*，可以直接使用第一行或第二列的校验和来直接求得 *A_{1,2}*，无需花费时间恢复数据。

对于测试数据 *2*，可以先花费 *1* 小时恢复数据 *A_{1,1}*，然后用第一行和第一列的校验值和求得 *A_{1,2}* 和 *A_{2,1}*，最后利用第二行的校验值和恢复 *A_{2,2}*。因此，共花费 *1* 小时的时间。

对于测试数据 *3*，可以花费 *1* 小时恢复数据 *A_{1,1}* 以及花费 *1* 小时恢复数据 *A_{2,2}*，此后，就可以利用校验和来求出其他所有被替换的数据。因此，共花费 *2* 小时的时间。
