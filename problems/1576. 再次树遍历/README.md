## [1576. 再次树遍历](https://www.acwing.com/problem/content/1578/)

### 题目

通过使用栈可以以非递归方式实现二叉树的中序遍历。

例如，假设遍历一个如下图所示的 *6* 节点的二叉树（节点编号从 *1* 到 *6*）。

则堆栈操作为：push(1); push(2); push(3); pop(); pop(); push(4); pop(); pop(); push(5); push(6); pop(); pop()。

我们可以从此操作序列中生成唯一的二叉树。

你的任务是给出这棵树的后序遍历。

 ![3.png](https://cdn.acwing.com/media/article/image/2020/04/03/19_783e80c875-3.png)

### 输入格式

第一行包含整数 *N*，表示树中节点个数。

树中节点编号从 *1* 到 *N*。

接下来 *2N* 行，每行包含一个栈操作，格式为：

- `Push X`，将编号为 *X* 的节点压入栈中。
- `Pop`，弹出栈顶元素。

### 输出格式

输出这个二叉树的后序遍历序列。

数据保证有解，数和数之间用空格隔开，末尾不能有多余空格。

### 数据范围

*1 ≤ N ≤ 30*

### 输入样例：

```
6
Push 1
Push 2
Push 3
Pop
Pop
Push 4
Pop
Pop
Push 5
Push 6
Pop
Pop
```

### 输出样例：

```
3 4 2 6 5 1
```
