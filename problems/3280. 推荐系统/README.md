## [3280. 推荐系统](https://www.acwing.com/problem/content/3283/)

### 题目

某电商有编号为 *0* 到 *m-1* 的 *m* 类商品，包括家电、汽车、电动车、面包、化妆品等。

对于每个 app 新用户，每类商品初始有编号不同的 *n* 个商品，包括各个商家、品牌、供应商等。

在任何时刻，同类的任意两个商品的编号各不相同，不同类的任意两个商品的编号可能相同。

app 会给每个商品打分。

初始时，各类商品的编号和得分都相同。

在用户使用 app 时，会产生有效信息，包括喜欢、不喜欢等。

app 会根据这些信息，在某类商品 **增加** 或 **删除** 商品。

app 每次会推荐一部分商品给用户看。

一个简单的想法是，选出各类所有商品中得分最大的若干商品。

该方法虽然简单，但是如果某类商品可能得分特别高，这种简单想法就无法保证推荐商品的多样性。

因此，app 查询得分最大的若干商品，同时限制各类商品个数不能超过一个阈值。

将上述过程抽象成 *3* 种操作：操作 *1、2、3*，分别对应增加、删除、查询操作：

- `1 type commodity score` 表示在 `type` 类商品中增加编号为 `commodity` 的商品，该商品分数为 `score`。
- `2 type commodity` 表示在 `type` 类商品中删除编号为 `commodity` 的商品。
- `3 K k_0 k_1 ... k_{m-1}` 表示在各类所有商品中选出不超过 *K* 个（不一定要达到 *K* 个〉得分最大的商品，同时第 *i(0≤ i<m)* 类商品的个数不超过 *k_i*。在查询时，如果第 *a(0 ≤a<m)* 类商品中编号为 *b* 的商品和第 *A(0≤A<m)* 类商品中编号为 *B* 的商品得分相同:
    1. 当 *a=A* 时，选取编号为 *min(b,B)* 的商品;
    2. 当 *a≠A* 时，选取第 *min(a,A)* 类商品。

### 输入格式

输入的第一行包含两个正整数 *m* 和 *n*。

接下来 *n* 行，每行两个正整数 `id` 和 `score`。第 *1+j(1 ≤ j≤n)* 行表示所有 *m* 类商品的第 *j* 个商品的编号和得分。

接下来一行包含一个正整数 *op_{num}*，表示操作总数。其中，查询操作一共有 *op_{ask}* 个。

接下来 *op_{num}* 行，每行若干个正整数，格式对应 `1 type commodity score`、 `2 type commodity`、 `3 K k_0 k_1 ... k_{m-1}`。

### 输出格式

输出共 *op_{ask} × m* 行，对应 *op_{ask}* 个查询操作。第 *r × m + c,0 ≤r <op_{ask}, 1 ≤c ≤m* 行表示，在第 *r* 个查询操作中，第 *c* 类商品选出的商品编号，同类商品输出时先输出分值大的，分值相同时先输出标号小的。如果 *r* 个查询操作中，第 *c* 类商品没有选出任何商品，则该行输出 *-1*。

### 数据范围

 ![QQ截图20210223161044.png](https://cdn.acwing.com/media/article/image/2021/02/23/19_a47be62675-QQ截图20210223161044.png)

### 输入样例：

```
2 3
1 3
2 2
3 1
8
3 100 1 1
1 0 4 3
1 0 5 1
3 10 2 2
3 10 1 1
2 0 1
3 2 1 1
3 1 1 1
```

### 输出样例：

```
1
1
1 4
1 2
1
1
4
1
4
-1
```
