## [598. 夏洛克与排序](https://www.acwing.com/problem/content/600/)

### 题目

夏洛克和华生已经在他们的计算机编程课程中学习了排序。

现在，华生对并行计算感到好奇，他想通过将由整数 *1* 到 *N* 组成的一个排列分解成若干组块，然后分别对每一组块进行排序，再将它们连接起来，从而完成对整个排列的排序。

对于一种排列 *p_1,p_2,…,p_N*，划分的每一组块都应该是排列的一个连续子阵列：即序列 *p_i,p_{i + 1},…,p_j,(1 ≤ i ≤ j ≤ N)*。

华生想要将他的排列划分为包含一个或多个组块的有序列表，划分时不改变元素所在的顺序，使得排列中的每个元素恰好在一个组块中，并且位于前面组块的任意元素都比位于后面组块的任意元素小。

例如，对于排列 *[2,1,3,5,4]*，华生可以将它们划分为：*[[2,1,3],[5,4]]* 或 *[[2,1],[3,5,4]]* 或 *[[2,1],[3],[5,4]]* 或 *[[2,1,3,5,4]]*。

划分出的组块越多时，华生越开心;我们将排列 *p* 的能够划分的最大组块数表示为 *f(p)*。

在此示例中，最大组块数为 *3*。

华生想要考虑数字 *1* 到 *N* 的所有排列 *p*，并求出 *f(p)* 的平方和。

你能帮帮他吗？

由于平方和可能很大，请输出对 *M* 取模后的值。

### 输入格式

第一行包含整数 *T*，表示共有 *T* 组测试数据。

每组数据占一行，包含两个整数 *N* 和 *M*。

### 输出格式

每组数据输出一个结果，每个结果占一行。

结果表示为 `Case #x: y`，其中 *x* 是组别编号（从 *1* 开始），*y* 对于 *1* 到 *N* 的所有排列 *p* 的 *f(p)* 的平方和对 *M* 取模后的值。

### 数据范围

*1 ≤ T ≤ 100*,

*1 ≤ M ≤ 10^9*,

*1 ≤ N ≤ 5000*

### 输入样例：

```
3
1 2
2 4
3 7
```

### 输出样例：

```
Case #1: 1
Case #2: 1
Case #3: 6
```

### 样例解释

在样例#1中，只有一种排列。 *f([1]) = 1*。

在样例#2中，共有 *2* 种排列。*f([1, 2]) = 2，f([2, 1]) = 1*。

在样例#3中，共有 *6* 种排列。*f([1, 2, 3]) = 3，f([1, 3, 2]) = 2，f([2, 1, 3]) = 2，f([2, 3, 1]) = 1，f([3, 1, 2]) = 1，f([3, 2, 1]) = 1*。
